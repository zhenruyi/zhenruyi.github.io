<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon3/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon3/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon3/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon3/android-chrome-384x384.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhenruyi.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":20,"offset":45},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":null,"post_header":null,"post_body":null,"coll_header":null,"sidebar":"fadeInDown"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《算法》第4章：图。 无向图，有向图，最小生成树，最短路径。">
<meta property="og:type" content="article">
<meta property="og:title" content="《算法》笔记：第4章  图">
<meta property="og:url" content="https://zhenruyi.github.io/algo/algorithms4/index.html">
<meta property="og:site_name" content="zhenruyi">
<meta property="og:description" content="《算法》第4章：图。 无向图，有向图，最小生成树，最短路径。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhenruyi.github.io/images/algo-learn03Algorithms04Graph1.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/algo-learn03Algorithms04Graph2.png">
<meta property="article:published_time" content="2022-04-15T02:09:55.000Z">
<meta property="article:modified_time" content="2022-04-16T23:04:23.422Z">
<meta property="article:author" content="luyizheng">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhenruyi.github.io/images/algo-learn03Algorithms04Graph1.png">


<link rel="canonical" href="https://zhenruyi.github.io/algo/algorithms4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zhenruyi.github.io/algo/algorithms4/","path":"algo/algorithms4/","title":"《算法》笔记：第4章  图"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《算法》笔记：第4章  图 | zhenruyi</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zhenruyi</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">done is better than perfect</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">7</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">16</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">39</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-text">4.1 无向图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E6%9C%AF%E8%AF%AD%E8%A1%A8"><span class="nav-text">4.1.1 术语表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E8%A1%A8%E7%A4%BA%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.1.2 表示无向图的数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">4.1.3 深度优先搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E5%AF%BB%E6%89%BE%E8%B7%AF%E5%BE%84"><span class="nav-text">4.1.4 寻找路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">4.1.5 广度优先搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-6-%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-text">4.1.6 连通分量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-7-%E7%AC%A6%E5%8F%B7%E5%9B%BE"><span class="nav-text">4.1.7 符号图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-8-%E6%80%BB%E7%BB%93"><span class="nav-text">4.1.8 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-text">4.2 有向图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E6%9C%AF%E8%AF%AD"><span class="nav-text">4.2.1 术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.2.2 数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="nav-text">4.2.3 可达性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E7%8E%AF%E5%92%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="nav-text">4.2.4 环和有向无环图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-text">4.2.5 强连通性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-6-%E6%80%BB%E7%BB%93"><span class="nav-text">4.2.6 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">4.3 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%8E%9F%E7%90%86"><span class="nav-text">4.3.1 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%8A%A0%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.3.2 加权无向图的数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91API"><span class="nav-text">4.3.3 最小生成树API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-Prim%E7%AE%97%E6%B3%95"><span class="nav-text">4.3.4 Prim算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-Prim%E7%AE%97%E6%B3%95%E7%9A%84%E5%8D%B3%E6%97%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.3.5 Prim算法的即时实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-6-Kruskal%E7%AE%97%E6%B3%95"><span class="nav-text">4.3.6 Kruskal算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-7-%E5%B1%95%E6%9C%9B"><span class="nav-text">4.3.7 展望</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">4.4 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E6%80%A7%E8%B4%A8"><span class="nav-text">4.4.1 性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">4.4.2 加权有向图的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">4.4.3 理论基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">4.4.4 Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-5-%E6%97%A0%E7%8E%AF%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-text">4.4.5 无环加权有向图的最短路径算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-6-%E4%B8%80%E8%88%AC%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-text">4.4.6 一般加权有向图的最短路径问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-7-%E5%B1%95%E6%9C%9B"><span class="nav-text">4.4.7 展望</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyizheng"
      src="/images/avatar2.jpg">
  <p class="site-author-name" itemprop="name">luyizheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhenruyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhenruyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/jugenlu" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;jugenlu" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://m.weibo.cn/u/3017941811" title="Weibo → https:&#x2F;&#x2F;m.weibo.cn&#x2F;u&#x2F;3017941811" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cs19b022@163.com" title="E-Mail → mailto:cs19b022@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/24837978" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;24837978" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://zhenruyi.github.io/images/OfficialAccountCode.jpg" title="WechatOfficial → https:&#x2F;&#x2F;zhenruyi.github.io&#x2F;images&#x2F;OfficialAccountCode.jpg"><i class="fab fa-weixin fa-fw"></i>WechatOfficial</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      they are very lovely
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672346917/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672346917&#x2F;" rel="noopener" target="_blank">AVA向晚</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672353429/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672353429&#x2F;" rel="noopener" target="_blank">Bella贝拉</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/351609538/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;351609538&#x2F;" rel="noopener" target="_blank">Carol珈乐</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672328094/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672328094&#x2F;" rel="noopener" target="_blank">Diana嘉然</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672342685/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672342685&#x2F;" rel="noopener" target="_blank">Eileen乃琳</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhenruyi.github.io/algo/algorithms4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.jpg">
      <meta itemprop="name" content="luyizheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhenruyi">
      <meta itemprop="description" content="">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《算法》笔记：第4章  图 | zhenruyi">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《算法》笔记：第4章  图
        </h1>

        <div class="post-meta-container">

        

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-15 10:09:55" itemprop="dateCreated datePublished" datetime="2022-04-15T10:09:55+08:00">2022-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-17 07:04:23" itemprop="dateModified" datetime="2022-04-17T07:04:23+08:00">2022-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>《算法》第4章：图。</p>
<p>无向图，有向图，最小生成树，最短路径。</p>
<span id="more"></span>



<hr>
<p>4种最重要的图模型：无向图（简单链接）、有向图（方向性）、加权图（带有权值）和加权有向图（既有方向性又带有权值）。</p>
<hr>
<h3 id="4-1-无向图"><a href="#4-1-无向图" class="headerlink" title="4.1 无向图"></a>4.1 无向图</h3><ul>
<li><p>使用0至V-1来表示一张含有V个顶点各个顶点；</p>
</li>
<li><p>v-w表示连接v和w的边；</p>
</li>
<li><p>特殊的图：含有平行边的称为多重图，没有平行边或自环的称为简单图。</p>
<ul>
<li>自环：一条连接到自己的边。</li>
<li>平行边：同一对顶点的边。</li>
</ul>
</li>
</ul>
<h4 id="4-1-1-术语表"><a href="#4-1-1-术语表" class="headerlink" title="4.1.1 术语表"></a>4.1.1 术语表</h4><p>和图相关的术语很多：</p>
<ul>
<li>相邻：两个顶点通过一条边相连。</li>
<li>度数：依附顶点的边的条数。</li>
<li>子图：由一幅图的所有边的一个子集组成的图。</li>
<li>路径：由边顺序连接的一系列顶点。<ul>
<li>简单路径：没有重复顶点的路径。</li>
<li>环：起点和终点相同。</li>
<li>简单环：除起点和终点之外没有重复顶点和边。</li>
<li>长度：所包含的边数。</li>
</ul>
</li>
<li>连通图：任意一个顶点都能到达另一个顶点。</li>
<li>无环图：没有环。</li>
<li>树：无环连通图。<ul>
<li>森林：互不相连的树组成的集合。</li>
<li>生成树：连通图的生成树是它的一副子图，含有图中所有顶点且是一棵树。</li>
</ul>
</li>
<li>二分图：将所有结点分为两部分的图。</li>
</ul>
<h4 id="4-1-2-表示无向图的数据类型"><a href="#4-1-2-表示无向图的数据类型" class="headerlink" title="4.1.2 表示无向图的数据类型"></a>4.1.2 表示无向图的数据类型</h4><p>最常用的图处理算法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Degree</span><span class="params">(g Graph, v <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(g.Adj(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxDegree</span><span class="params">(g Graph)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	max := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; g.V; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> d := Degree(g, i); d &gt; max &#123;</span><br><span class="line">			max = d</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AvgDegree</span><span class="params">(graph Graph)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2.0</span> * <span class="type">float64</span>(graph.E) / <span class="type">float64</span>(graph.V)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NOfSelfLoops</span><span class="params">(graph Graph)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="number">0</span>; v &lt; graph.V; v++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, w := <span class="keyword">range</span> graph.Adj(v) &#123;</span><br><span class="line">			<span class="keyword">if</span> w == v &#123;</span><br><span class="line">				count++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToString</span><span class="params">(g Graph)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	s := fmt.Sprintf(<span class="string">&quot;%v vertices, %v edges\n&quot;</span>, g.V, g.E)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="number">0</span>; v &lt; g.V; v++ &#123;</span><br><span class="line">		s += fmt.Sprintf(<span class="string">&quot;%v: &quot;</span>, v)</span><br><span class="line">		<span class="keyword">for</span> _, w := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">			s += fmt.Sprintf(<span class="string">&quot;%v &quot;</span>, w)</span><br><span class="line">		&#125;</span><br><span class="line">		s += <span class="string">&quot;\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Graph数据类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123;</span><br><span class="line">	V <span class="type">int</span></span><br><span class="line">	E <span class="type">int</span></span><br><span class="line">	adj []Chapter01Foundation.ListBag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGraph</span><span class="params">(v <span class="type">int</span>)</span></span> *Graph &#123;</span><br><span class="line">	 <span class="keyword">return</span> &amp;Graph&#123;</span><br><span class="line">		V: v,</span><br><span class="line">		E: <span class="number">0</span>,</span><br><span class="line">		adj: <span class="built_in">make</span>([]Chapter01Foundation.ListBag, v),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span></span> AddEdge(v, w <span class="type">int</span>) &#123;</span><br><span class="line">	g.adj[v].Add(w)</span><br><span class="line">	g.adj[w].Add(v)</span><br><span class="line">	g.E++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span></span> Adj(v <span class="type">int</span>) []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> g.adj[v].Iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-深度优先搜索"><a href="#4-1-3-深度优先搜索" class="headerlink" title="4.1.3 深度优先搜索"></a>4.1.3 深度优先搜索</h4><p>跟路径相关，需要使用深度优先搜索。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DepthFirstSearch <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span></span><br><span class="line">	count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDepthFirstSearch</span><span class="params">(g Graph, s <span class="type">int</span>)</span></span> *DepthFirstSearch &#123;</span><br><span class="line">	d := <span class="built_in">new</span>(DepthFirstSearch)</span><br><span class="line">	d.count = <span class="number">0</span></span><br><span class="line">	d.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	d.DFS(g, s)</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DepthFirstSearch)</span></span> DFS(g Graph, v <span class="type">int</span>) &#123;</span><br><span class="line">	d.marked[v] = <span class="literal">true</span></span><br><span class="line">	d.count++</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		<span class="keyword">if</span> !d.marked[w.(<span class="type">int</span>)] &#123;</span><br><span class="line">			d.DFS(g, w.(<span class="type">int</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-4-寻找路径"><a href="#4-1-4-寻找路径" class="headerlink" title="4.1.4 寻找路径"></a>4.1.4 寻找路径</h4><p>单点路径：给定一幅图和一个起点，到目的顶点是否存在一条路径，找出这条路径。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否有一条路径</span></span><br><span class="line"><span class="keyword">type</span> DepthFirstPaths <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span>	<span class="comment">//这个顶点上调用过DFS吗？</span></span><br><span class="line">	edgeTo []<span class="type">int</span>	<span class="comment">//从起点到一个顶点的已知路径上的最后一个顶点</span></span><br><span class="line">	s <span class="type">int</span>			<span class="comment">//起点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDepthFirstPaths</span><span class="params">(g Graph, start <span class="type">int</span>)</span></span> *DepthFirstPaths &#123;</span><br><span class="line">	p := <span class="built_in">new</span>(DepthFirstPaths)</span><br><span class="line">	p.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	p.edgeTo = <span class="built_in">make</span>([]<span class="type">int</span>, g.V)</span><br><span class="line">	p.s = start</span><br><span class="line">	p.DFS(g, start)</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *DepthFirstPaths)</span></span> DFS(g Graph, v <span class="type">int</span>) &#123;</span><br><span class="line">	p.marked[v] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		<span class="keyword">if</span> !p.marked[w.(<span class="type">int</span>)] &#123;</span><br><span class="line">			p.edgeTo[w.(<span class="type">int</span>)] = v</span><br><span class="line">			p.DFS(g, w.(<span class="type">int</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *DepthFirstPaths)</span></span> HasPathTo(v <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.marked[v]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *DepthFirstPaths)</span></span> PathTo(v <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !p.HasPathTo(v) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> x := v; x != p.s; x = p.edgeTo[x] &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, x)</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">append</span>(ret, p.s)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-5-广度优先搜索"><a href="#4-1-5-广度优先搜索" class="headerlink" title="4.1.5 广度优先搜索"></a>4.1.5 广度优先搜索</h4><p>处理最短路径的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BreadthFirstPaths <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span></span><br><span class="line">	edgeTo []<span class="type">int</span></span><br><span class="line">	start <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBreadthFirstPaths</span><span class="params">(g Graph, s <span class="type">int</span>)</span></span> *BreadthFirstPaths &#123;</span><br><span class="line">	ret := <span class="built_in">new</span>(BreadthFirstPaths)</span><br><span class="line">	ret.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	ret.edgeTo = <span class="built_in">make</span>([]<span class="type">int</span>, g.V)</span><br><span class="line">	ret.start = s</span><br><span class="line">	ret.BFS(g, s)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *BreadthFirstPaths)</span></span> BFS(g Graph, s <span class="type">int</span>) &#123;</span><br><span class="line">	l := list.New()</span><br><span class="line">	p.marked[s] = <span class="literal">true</span></span><br><span class="line">	l.PushBack(s)</span><br><span class="line">	<span class="keyword">for</span> l.Len() != <span class="number">0</span> &#123;</span><br><span class="line">		v := l.Remove(l.Front()).(<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">for</span> _, wRow := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">			w := wRow.(<span class="type">int</span>)</span><br><span class="line">			<span class="keyword">if</span> !p.marked[w] &#123;</span><br><span class="line">				p.edgeTo[w] = v</span><br><span class="line">				p.marked[w] = <span class="literal">true</span></span><br><span class="line">				l.PushBack(w)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *BreadthFirstPaths)</span></span> HasPathTo(v <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.marked[v]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *BreadthFirstPaths)</span></span> PathTo(v <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !p.HasPathTo(v) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> x := v; x != p.start; x = p.edgeTo[x] &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, x)</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">append</span>(ret, p.start)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-6-连通分量"><a href="#4-1-6-连通分量" class="headerlink" title="4.1.6 连通分量"></a>4.1.6 连通分量</h4><p>一个图的极大连通子图称为连通分量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CC <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span>	</span><br><span class="line">	id []<span class="type">int</span>	<span class="comment">//连通分量的编号</span></span><br><span class="line">	count <span class="type">int</span>	<span class="comment">//当前编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCC</span><span class="params">(g Graph)</span></span> *CC &#123;</span><br><span class="line">	ret := <span class="built_in">new</span>(CC)</span><br><span class="line">	ret.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	ret.count = <span class="number">0</span></span><br><span class="line">	ret.id = <span class="built_in">make</span>([]<span class="type">int</span>, g.V)</span><br><span class="line">	<span class="keyword">for</span> s := <span class="number">0</span>; s &lt; g.V; s++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !ret.marked[s] &#123;</span><br><span class="line">			ret.DFS(g, s)</span><br><span class="line">			ret.count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *CC)</span></span> DFS(g Graph, v <span class="type">int</span>) &#123;</span><br><span class="line">	cc.marked[v] = <span class="literal">true</span></span><br><span class="line">	cc.id[v] = cc.count</span><br><span class="line">	<span class="keyword">for</span> _, wRow := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		w := wRow.(<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">if</span> !cc.marked[w] &#123;</span><br><span class="line">			cc.DFS(g, w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *CC)</span></span> Connected(v, w <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cc.id[v] == cc.id[w]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用深度优先算法处理图的其他实例</p>
<div class="pdf-container" data-target="https://zhenruyi.github.io/files/DFSOtherExamples.pdf" data-height="650px"></div>



<h4 id="4-1-7-符号图"><a href="#4-1-7-符号图" class="headerlink" title="4.1.7 符号图"></a>4.1.7 符号图</h4><p>使用字符串而非整数来表示和指代顶点。</p>
<p>书上的方法是，使用两个数组，一个对于索引-&gt;字符串，一个从字符串-&gt;索引。然后图还是使用整数表示顶点。</p>
<p>我用了一个map记录。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SymbolGraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 键为图的顶点，值为顶点的整数表示</span></span><br><span class="line">	<span class="comment">// 值为0时，表示顶点不存在，从1开始计算。</span></span><br><span class="line">	index <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	graph *Graph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSymbolGraph</span><span class="params">(filePath <span class="type">string</span>)</span></span> *SymbolGraph &#123;</span><br><span class="line">	sg := <span class="built_in">new</span>(SymbolGraph)</span><br><span class="line">	sg.index = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	file, err := os.Open(filePath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open error&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	br := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		row, _, c := br.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> c == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		data := <span class="type">string</span>(row)</span><br><span class="line">		splits := strings.Split(data, <span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> splits &#123;</span><br><span class="line">			<span class="keyword">if</span> sg.index[v] == <span class="number">0</span> &#123;</span><br><span class="line">				sg.index[v] = count</span><br><span class="line">				count++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sg.graph = NewGraph(count<span class="number">-1</span>)</span><br><span class="line">	br = bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		row, _, c := br.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> c == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		data := <span class="type">string</span>(row)</span><br><span class="line">		splits := strings.Split(data, <span class="string">&quot; &quot;</span>)</span><br><span class="line">		v := sg.index[splits[<span class="number">0</span>]] - <span class="number">1</span></span><br><span class="line">		w := sg.index[splits[<span class="number">1</span>]] - <span class="number">1</span></span><br><span class="line">		sg.graph.AddEdge(v, w)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *SymbolGraph)</span></span> Contains(s <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sg.index[s] != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *SymbolGraph)</span></span> Index(s <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sg.index[s] - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sg *SymbolGraph)</span></span> Name(v <span class="type">int</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> key, val := <span class="keyword">range</span> sg.index &#123;</span><br><span class="line">		<span class="keyword">if</span> v == val - <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> key</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-8-总结"><a href="#4-1-8-总结" class="headerlink" title="4.1.8 总结"></a>4.1.8 总结</h4><p>基本概念：</p>
<ul>
<li>图的术语；</li>
<li>图的表示方法；</li>
<li>深度优先，广度优先；</li>
<li>符号图。</li>
</ul>
<hr>
<h3 id="4-2-有向图"><a href="#4-2-有向图" class="headerlink" title="4.2 有向图"></a>4.2 有向图</h3><p>在有向图种，边是单向的。</p>
<h4 id="4-2-1-术语"><a href="#4-2-1-术语" class="headerlink" title="4.2.1 术语"></a>4.2.1 术语</h4><ul>
<li>出度：指出的边的数量。</li>
<li>头尾：第一个顶点称为头，第二个顶点称为尾。</li>
<li>有向路径，有向环。</li>
<li>简单有向环：不存在重复的顶点和边的环。</li>
</ul>
<h4 id="4-2-2-数据类型"><a href="#4-2-2-数据类型" class="headerlink" title="4.2.2 数据类型"></a>4.2.2 数据类型</h4><p>有向图取反reverse()方法，返回有向图的一个副本，但所有的边方向反转。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Digraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	V <span class="type">int</span></span><br><span class="line">	E <span class="type">int</span></span><br><span class="line">	adj []Chapter01Foundation.ListBag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDigraph</span><span class="params">(v <span class="type">int</span>)</span></span> *Digraph &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Digraph&#123;</span><br><span class="line">		V: v,</span><br><span class="line">		E: <span class="number">0</span>,</span><br><span class="line">		adj: <span class="built_in">make</span>([]Chapter01Foundation.ListBag, v),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Digraph)</span></span> AddEdge(v, w <span class="type">int</span>) &#123;</span><br><span class="line">	g.adj[v].Add(w)</span><br><span class="line">	g.E++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Digraph)</span></span> Adj(v <span class="type">int</span>) []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> g.adj[v].Iterator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Digraph)</span></span> Reverse() *Digraph &#123;</span><br><span class="line">	ret := NewDigraph(g.V)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="number">0</span>; v &lt; g.V; v++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, row := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">			w := row.(<span class="type">int</span>)</span><br><span class="line">			ret.AddEdge(w, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-3-可达性"><a href="#4-2-3-可达性" class="headerlink" title="4.2.3 可达性"></a>4.2.3 可达性</h4><p>深度优先搜索。</p>
<p>有向图寻路：s -&gt; v</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DirectedDFS <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirectedDFS</span><span class="params">(g Graph, s <span class="type">int</span>)</span></span> *DirectedDFS &#123;</span><br><span class="line">	d := <span class="built_in">new</span>(DirectedDFS)</span><br><span class="line">	d.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	d.DFS(g, s)</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DirectedDFS)</span></span> DFS(g Graph, v <span class="type">int</span>) &#123;</span><br><span class="line">	d.marked[v] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		<span class="keyword">if</span> !d.marked[w.(<span class="type">int</span>)] &#123;</span><br><span class="line">			d.DFS(g, w.(<span class="type">int</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-4-环和有向无环图"><a href="#4-2-4-环和有向无环图" class="headerlink" title="4.2.4 环和有向无环图"></a>4.2.4 环和有向无环图</h4><p>处理优先级限制下的调度问题，有向图出现环会让调度进入循环。</p>
<p>寻找环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DirectedCycle <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span></span><br><span class="line">	edgeTo []<span class="type">int</span></span><br><span class="line">	cycle list.List</span><br><span class="line">	onStack []<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirectedCycle</span><span class="params">(g Graph)</span></span> *DirectedCycle &#123;</span><br><span class="line">	ret := &amp;DirectedCycle&#123;</span><br><span class="line">		onStack: <span class="built_in">make</span>([]<span class="type">bool</span>, g.V),</span><br><span class="line">		edgeTo: <span class="built_in">make</span>([]<span class="type">int</span>, g.V),</span><br><span class="line">		marked: <span class="built_in">make</span>([]<span class="type">bool</span>, g.V),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> v:=<span class="number">0</span>; v &lt; g.V; v++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !ret.marked[v] &#123;</span><br><span class="line">			ret.DFS(g, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DirectedCycle)</span></span> DFS(g Graph, v <span class="type">int</span>) &#123;</span><br><span class="line">	d.onStack[v] = <span class="literal">true</span></span><br><span class="line">	d.marked[v] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, row := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		w := row.(<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">if</span> d.HasCycle() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !d.marked[w] &#123;</span><br><span class="line">			d.edgeTo[w] = v</span><br><span class="line">			d.DFS(g, w)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> d.onStack[w] &#123;</span><br><span class="line">			d.cycle = list.New()</span><br><span class="line">			<span class="keyword">for</span> x:=v; x != w; x = d.edgeTo[x] &#123;</span><br><span class="line">				d.cycle.PushFront(x)</span><br><span class="line">			&#125;</span><br><span class="line">			d.cycle.PushFront(w)</span><br><span class="line">			d.cycle.PushFront(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DirectedCycle)</span></span> HasCycle() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> d.cycle.Len() != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DirectedCycle)</span></span> Cycle() list.List &#123;</span><br><span class="line">	<span class="keyword">return</span> d.cycle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-5-强连通性"><a href="#4-2-5-强连通性" class="headerlink" title="4.2.5 强连通性"></a>4.2.5 强连通性</h4><p>如果两个顶点是相互可达的，称它们为强连通的。如果一幅图中任意两个顶点都是强连通的，则称这幅图是强连通的。</p>
<p>强连通分量：相互均为强连通的顶点的最大子集。</p>
<p>要另外实现一个取反操作才能进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KasarajuSCC <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span></span><br><span class="line">	id []<span class="type">int</span>	<span class="comment">//连通分量的编号</span></span><br><span class="line">	count <span class="type">int</span>	<span class="comment">//当前编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKasarajuSCC</span><span class="params">(g Graph)</span></span> *KasarajuSCC &#123;</span><br><span class="line">	ret := <span class="built_in">new</span>(KasarajuSCC)</span><br><span class="line">	ret.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	ret.count = <span class="number">0</span></span><br><span class="line">	ret.id = <span class="built_in">make</span>([]<span class="type">int</span>, g.V)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	for s := 0; s &lt; g.V; s++ &#123;</span></span><br><span class="line"><span class="comment">		if !ret.marked[s] &#123;</span></span><br><span class="line"><span class="comment">			ret.DFS(g, s)</span></span><br><span class="line"><span class="comment">			ret.count++</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *KasarajuSCC)</span></span> DFS(g Graph, v <span class="type">int</span>) &#123;</span><br><span class="line">	cc.marked[v] = <span class="literal">true</span></span><br><span class="line">	cc.id[v] = cc.count</span><br><span class="line">	<span class="keyword">for</span> _, wRow := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		w := wRow.(<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">if</span> !cc.marked[w] &#123;</span><br><span class="line">			cc.DFS(g, w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *KasarajuSCC)</span></span> StronglyConnected(v, w <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cc.id[v] == cc.id[w]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-6-总结"><a href="#4-2-6-总结" class="headerlink" title="4.2.6 总结"></a>4.2.6 总结</h4><p><img src="https://zhenruyi.github.io/images/algo-learn03Algorithms04Graph1.png"></p>
<hr>
<h3 id="4-3-最小生成树"><a href="#4-3-最小生成树" class="headerlink" title="4.3 最小生成树"></a>4.3 最小生成树</h3><p>加权图是为每条边关联一个权值或成本的图模型。</p>
<p>最小生成树是图的一棵含有其他所有顶点的无环连通子图。</p>
<p>最小生成树的两种经典算法：Prim算法和Kruskal算法。</p>
<h4 id="4-3-1-原理"><a href="#4-3-1-原理" class="headerlink" title="4.3.1 原理"></a>4.3.1 原理</h4><p>树的两个最重要的性质：</p>
<ul>
<li>用一条边连接树中的任意两个顶点会产生一个新的环；</li>
<li>从树中删去一条边会得到两棵独立的树。</li>
</ul>
<p>图的一种切分是将图的所有顶点分为两个非空且不重复的集合，横切边是一条连接两个属于不同集合的顶点的边。</p>
<p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中权值最小者必然属于图的最小生成树。</p>
<p>切分定理是解决最小生成树问题的所有算法的基础。更确切地说，这些算法是贪心算法地特殊情况，使用切分定理找到一条边，不断重复直到找到最小生成树的所有边。</p>
<p>最小生成树的贪心算法：将V个顶点的任意加权连通图中属于最小生成树的边标记为黑色。初始状态下均为灰色，找到一种切分，它产生的横切边都不是黑色，将它权重最小的横切边标记为黑色。反复，直到标记V-1条黑色的边为止。</p>
<h4 id="4-3-2-加权无向图的数据类型"><a href="#4-3-2-加权无向图的数据类型" class="headerlink" title="4.3.2 加权无向图的数据类型"></a>4.3.2 加权无向图的数据类型</h4><p>带权重的边的数据类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123;</span><br><span class="line">	v, w <span class="type">int</span></span><br><span class="line">	weight <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEdge</span><span class="params">(v, w <span class="type">int</span>, wgh <span class="type">float64</span>)</span></span> *Edge &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Edge&#123;</span><br><span class="line">		v: v,</span><br><span class="line">		w: w,</span><br><span class="line">		weight: wgh,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Edge)</span></span> Either() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Edge)</span></span> Other(v <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v == e.v &#123;</span><br><span class="line">		<span class="keyword">return</span> e.w</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v == e.w &#123;</span><br><span class="line">		<span class="keyword">return</span> e.v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Edge)</span></span> CmpTo(that Edge) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.weight &gt; that.weight &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e.weight &lt; that.weight &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加权无向图的数据类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EdgeWeightedGraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	V <span class="type">int</span></span><br><span class="line">	E <span class="type">int</span></span><br><span class="line">	adj []Chapter01Foundation.ListBag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEdgeWeightedGraph</span><span class="params">(v <span class="type">int</span>)</span></span> *EdgeWeightedGraph &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;EdgeWeightedGraph&#123;</span><br><span class="line">		V: v,</span><br><span class="line">		E: <span class="number">0</span>,</span><br><span class="line">		adj: <span class="built_in">make</span>([]Chapter01Foundation.ListBag, v),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *EdgeWeightedGraph)</span></span> AddEdge(e Edge) &#123;</span><br><span class="line">	v, w := e.v, e.w</span><br><span class="line">	g.adj[v].Add(e)</span><br><span class="line">	g.adj[w].Add(e)</span><br><span class="line">	g.E++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-3-最小生成树API"><a href="#4-3-3-最小生成树API" class="headerlink" title="4.3.3 最小生成树API"></a>4.3.3 最小生成树API</h4><p>edges()返回最小生成树的所有边。</p>
<p>weigh()返回最小生成树的权重。</p>
<h4 id="4-3-4-Prim算法"><a href="#4-3-4-Prim算法" class="headerlink" title="4.3.4 Prim算法"></a>4.3.4 Prim算法</h4><p>每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权值最小的边加入树中。</p>
<p>最小生成树的Prim算法的延时实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LazyPrimMST <span class="keyword">struct</span> &#123;</span><br><span class="line">	marked []<span class="type">bool</span>	<span class="comment">// 顶点</span></span><br><span class="line">	mst *Chapter01Foundation.ListQueue  <span class="comment">// 边</span></span><br><span class="line">	<span class="comment">// 横切边，原文是最小队列，我是最大队列</span></span><br><span class="line">	<span class="comment">//pq *Chapter02Sorting.MaxPriorityQueue</span></span><br><span class="line">	pq *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *LazyPrimMST)</span></span> Visit(g EdgeWeightedGraph, v <span class="type">int</span>) &#123;</span><br><span class="line">	p.marked[v] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, row := <span class="keyword">range</span> g.Adj(v) &#123;</span><br><span class="line">		e := row.(Edge)</span><br><span class="line">		<span class="keyword">if</span> !p.marked[e.Other(v)] &#123;</span><br><span class="line">			p.pq.PushFront(e)</span><br><span class="line">			p.SortList()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *LazyPrimMST)</span></span> SortList() &#123;</span><br><span class="line">	<span class="keyword">if</span> p.pq.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	min := p.pq.Front()</span><br><span class="line">	<span class="keyword">for</span> po := p.pq.Front(); po != <span class="literal">nil</span>; po = po.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> po.Value.(Edge).weight &lt; min.Value.(Edge).weight &#123;</span><br><span class="line">			min = po</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.pq.MoveBefore(min, p.pq.Front())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLazyPrimMST</span><span class="params">(g EdgeWeightedGraph)</span></span> *LazyPrimMST &#123;</span><br><span class="line">	ret := <span class="built_in">new</span>(LazyPrimMST)</span><br><span class="line">	ret.pq = list.New()</span><br><span class="line">	ret.marked = <span class="built_in">make</span>([]<span class="type">bool</span>, g.V)</span><br><span class="line">	ret.mst = <span class="built_in">new</span>(Chapter01Foundation.ListQueue)</span><br><span class="line">	ret.Visit(g, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> ret.pq.Len() != <span class="number">0</span> &#123;</span><br><span class="line">		e := ret.pq.Remove(ret.pq.Front()).(Edge)</span><br><span class="line">		ret.SortList()</span><br><span class="line">		v := e.Either()</span><br><span class="line">		w := e.Other(v)</span><br><span class="line">		<span class="keyword">if</span> ret.marked[v] &amp;&amp; ret.marked[w] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		ret.mst.Enqueue(e)</span><br><span class="line">		<span class="keyword">if</span> !ret.marked[v] &#123;</span><br><span class="line">			ret.Visit(g, v)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !ret.marked[w] &#123;</span><br><span class="line">			ret.Visit(g, w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-5-Prim算法的即时实现"><a href="#4-3-5-Prim算法的即时实现" class="headerlink" title="4.3.5 Prim算法的即时实现"></a>4.3.5 Prim算法的即时实现</h4><p>不需要保存所有的边，只需要保存权值最小的边，只会在优先队列保存每个非树顶点w的一条边，这条边是与树中顶点连接起来的权值最小的边。</p>
<h4 id="4-3-6-Kruskal算法"><a href="#4-3-6-Kruskal算法" class="headerlink" title="4.3.6 Kruskal算法"></a>4.3.6 Kruskal算法</h4><p>按照权值顺序处理它们，将边加入最小生成树中，加入的表不会构成环，直到加入V-1条边。</p>
<h4 id="4-3-7-展望"><a href="#4-3-7-展望" class="headerlink" title="4.3.7 展望"></a>4.3.7 展望</h4><p><img src="https://zhenruyi.github.io/images/algo-learn03Algorithms04Graph2.png"></p>
<hr>
<h3 id="4-4-最短路径"><a href="#4-4-最短路径" class="headerlink" title="4.4 最短路径"></a>4.4 最短路径</h3><p>最短路径是权重最小者。</p>
<h4 id="4-4-1-性质"><a href="#4-4-1-性质" class="headerlink" title="4.4.1 性质"></a>4.4.1 性质</h4><ul>
<li>路径是有向的。</li>
<li>权重不一定等价于距离，可能是时间等。</li>
<li>并不是所有顶点都是可达的，为了简化问题，假设都是强连通的。</li>
<li>最短路径不一定是唯一的，但是只需要找到一条就行。</li>
<li>最短路径树：以s为起点，包含s和从s可达的所有顶点。</li>
</ul>
<h4 id="4-4-2-加权有向图的数据结构"><a href="#4-4-2-加权有向图的数据结构" class="headerlink" title="4.4.2 加权有向图的数据结构"></a>4.4.2 加权有向图的数据结构</h4><p>加权有向边的数据类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DirectedEdge <span class="keyword">struct</span> &#123;</span><br><span class="line">	v <span class="type">int</span></span><br><span class="line">	w <span class="type">int</span></span><br><span class="line">	weight <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirectedEdge</span><span class="params">(v, w <span class="type">int</span>, weight <span class="type">float64</span>)</span></span> *DirectedEdge &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DirectedEdge&#123;v, w, weight&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(E *DirectedEdge)</span></span> From() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> E.v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(E *DirectedEdge)</span></span> To() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> E.w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加权有向图的数据类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EdgeWeightedDigraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	V <span class="type">int</span></span><br><span class="line">	E <span class="type">int</span></span><br><span class="line">	adj []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEdgeWeightedDigraph</span><span class="params">(v <span class="type">int</span>)</span></span> *EdgeWeightedDigraph &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;EdgeWeightedDigraph&#123;v, <span class="number">0</span>, <span class="built_in">make</span>([]list.List, v)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dg *EdgeWeightedDigraph)</span></span> AddEdge(e DirectedEdge) &#123;</span><br><span class="line">	dg.adj[e.From()].PushFront(e)</span><br><span class="line">	dg.E++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dg *EdgeWeightedDigraph)</span></span> Adj(v <span class="type">int</span>) *list.List &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;dg.adj[v]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dg *EdgeWeightedDigraph)</span></span> Edges() *list.List &#123;</span><br><span class="line">	ret := list.New()</span><br><span class="line">	<span class="keyword">for</span> v := <span class="number">0</span>; v &lt; dg.V; v++ &#123;</span><br><span class="line">		l := dg.adj[v]</span><br><span class="line">		<span class="keyword">for</span> tmp := l.Front(); tmp != <span class="literal">nil</span>; tmp = tmp.Next() &#123;</span><br><span class="line">			ret.PushBack(tmp.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-3-理论基础"><a href="#4-4-3-理论基础" class="headerlink" title="4.4.3 理论基础"></a>4.4.3 理论基础</h4><p>最短路径的最优性条件。</p>
<h4 id="4-4-4-Dijkstra算法"><a href="#4-4-4-Dijkstra算法" class="headerlink" title="4.4.4 Dijkstra算法"></a>4.4.4 Dijkstra算法</h4><h4 id="4-4-5-无环加权有向图的最短路径算法"><a href="#4-4-5-无环加权有向图的最短路径算法" class="headerlink" title="4.4.5 无环加权有向图的最短路径算法"></a>4.4.5 无环加权有向图的最短路径算法</h4><h4 id="4-4-6-一般加权有向图的最短路径问题"><a href="#4-4-6-一般加权有向图的最短路径问题" class="headerlink" title="4.4.6 一般加权有向图的最短路径问题"></a>4.4.6 一般加权有向图的最短路径问题</h4><h4 id="4-4-7-展望"><a href="#4-4-7-展望" class="headerlink" title="4.4.7 展望"></a>4.4.7 展望</h4><div class="pdf-container" data-target="https://zhenruyi.github.io/files/DijkstraAlgoOfShortest.pdf" data-height="650px"></div>



<hr>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/learn/" rel="tag"># learn</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/algo/algorithms3/" rel="prev" title="《算法》笔记：第3章  查找">
                  <i class="fa fa-chevron-left"></i> 《算法》笔记：第3章  查找
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/algo/algorithms5/" rel="next" title="《算法》笔记：第5章  字符串">
                  《算法》笔记：第5章  字符串 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyizheng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  





</body>
</html>
