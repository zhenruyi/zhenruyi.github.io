<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon3/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon3/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon3/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon3/android-chrome-384x384.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhenruyi.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":20,"offset":45},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":null,"post_header":null,"post_body":null,"coll_header":null,"sidebar":"fadeInDown"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="内容有：程序和进程概述、并行和并发、pcb进程信息管理、进程状态转换、进程相关命令、fork函数、父子进程用户区数据读写、多进程gdb调试、exec族函数、结束进程、孤儿进程、僵尸进程、wait、waitpid函数、进程间通信简介、匿名管道、有名管道、内存映射、信号、进程组和会话、守护进程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux多进程开发">
<meta property="og:url" content="https://zhenruyi.github.io/linux/webServer2/index.html">
<meta property="og:site_name" content="zhenruyi">
<meta property="og:description" content="内容有：程序和进程概述、并行和并发、pcb进程信息管理、进程状态转换、进程相关命令、fork函数、父子进程用户区数据读写、多进程gdb调试、exec族函数、结束进程、孤儿进程、僵尸进程、wait、waitpid函数、进程间通信简介、匿名管道、有名管道、内存映射、信号、进程组和会话、守护进程。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-1.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-2.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-3.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-4.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-5.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-6.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-7.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-8.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-9.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-10.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-11.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-12.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-13.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-14.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-15.jpg">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-15.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-16.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-17.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-18.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-19.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-20.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-21.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-22.png">
<meta property="og:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-23.png">
<meta property="article:published_time" content="2022-04-18T10:08:42.000Z">
<meta property="article:modified_time" content="2022-04-21T07:14:11.095Z">
<meta property="article:author" content="luyizheng">
<meta property="article:tag" content="webServer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-1.png">


<link rel="canonical" href="https://zhenruyi.github.io/linux/webServer2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zhenruyi.github.io/linux/webServer2/","path":"linux/webServer2/","title":"Linux多进程开发"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux多进程开发 | zhenruyi</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zhenruyi</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">done is better than perfect</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">7</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">16</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">38</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">1 进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-text">1.1 程序和进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8D%95%E9%81%93%E3%80%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">1.2 单道、多道程序设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E6%97%B6%E9%97%B4%E7%89%87"><span class="nav-text">1.3 时间片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-text">1.4 并行和并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89"><span class="nav-text">1.5 进程控制块（PCB）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-text">2 进程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.1 进程状态的三态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.2 进程状态的五态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">2.3 进程相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%BF%AB%E7%85%A7%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89"><span class="nav-text">2.3.1 查看进程快照（静态）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.3.2 实时显示进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.3.3 杀死进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-text">2.4 进程号和相关函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">3 进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">3.1 进程创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-text">3.2 父子进程虚拟地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-GDB%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-text">3.3 GDB多进程调试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-text">4 exec函数族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">5 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-text">5.1 进程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-text">5.2 孤儿进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">5.3 僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-text">5.4 进程回收</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">6 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">6.1 匿名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-1-%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">6.1.1 管道的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="nav-text">6.1.2 为什么可以使用管道进行进程间通信？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-3-%E7%AE%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">6.1.3 管道的数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-4-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="nav-text">6.1.4 父子进程通过管道进行通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-5-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B"><span class="nav-text">6.1.5 匿名管道的通信案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-6-%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E7%89%B9%E7%82%B9"><span class="nav-text">6.1.6 管道读写特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-7-%E7%AE%A1%E9%81%93%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text">6.1.7 管道设置为非阻塞</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">6.2 有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-1-%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">6.2.1 创建有名管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-2-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">6.2.2 有名管道的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-3-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD"><span class="nav-text">6.2.3 实现简单版聊天功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">7 内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E5%87%BD%E6%95%B0"><span class="nav-text">7.1 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">7.2 注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">7.3 实现复制文件操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84"><span class="nav-text">7.4 匿名映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BF%A1%E5%8F%B7"><span class="nav-text">8 信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E4%BF%A1%E5%8F%B7%E5%88%97%E8%A1%A8"><span class="nav-text">8.1 信号列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-%E4%BF%A1%E5%8F%B7%E7%9A%845%E7%A7%8D%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%8A%A8%E4%BD%9C"><span class="nav-text">8.2 信号的5种默认处理动作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-Core%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E8%B0%83%E8%AF%95"><span class="nav-text">8.3 Core文件的生成和调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-kill%E3%80%81raise%E3%80%81abort%E5%87%BD%E6%95%B0"><span class="nav-text">8.4 kill、raise、abort函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-alarm%E5%87%BD%E6%95%B0"><span class="nav-text">8.5 alarm函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-6-setitimer%E5%87%BD%E6%95%B0"><span class="nav-text">8.6 setitimer函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-7-signal%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="nav-text">8.7 signal信号捕捉函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-8-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">8.8 信号集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-9-%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">8.9 阻塞信号集和未决信号集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-10-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">8.10 用户自定义信号集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-11-%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E9%9B%86%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">8.11 用自定义信号集修改系统信号集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-12-sigaction%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="nav-text">8.12 sigaction信号捕捉函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-13-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">8.13 内核实现信号捕捉的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-14-SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.14 SIGCHLD信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">9 共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text">9.1 使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-text">9.2 相关函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-text">9.3 实现案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">9.4 共享内存操作命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">10 守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-%E7%BB%88%E7%AB%AF"><span class="nav-text">10.1 终端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">10.2 进程组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-%E4%BC%9A%E8%AF%9D"><span class="nav-text">10.3 会话</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">10.4 进程、进程组、会话、控制终端之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-5-%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">10.5 进程组、会话的操作函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-6-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">10.6 守护进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-7-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-text">10.7 守护进程的创建步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-8-%E5%AE%9E%E4%BE%8B"><span class="nav-text">10.8 实例</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyizheng"
      src="/images/avatar2.jpg">
  <p class="site-author-name" itemprop="name">luyizheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhenruyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhenruyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/jugenlu" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;jugenlu" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://m.weibo.cn/u/3017941811" title="Weibo → https:&#x2F;&#x2F;m.weibo.cn&#x2F;u&#x2F;3017941811" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cs19b022@163.com" title="E-Mail → mailto:cs19b022@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/24837978" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;24837978" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://zhenruyi.github.io/images/OfficialAccountCode.jpg" title="WechatOfficial → https:&#x2F;&#x2F;zhenruyi.github.io&#x2F;images&#x2F;OfficialAccountCode.jpg"><i class="fab fa-weixin fa-fw"></i>WechatOfficial</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      they are very lovely
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672346917/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672346917&#x2F;" rel="noopener" target="_blank">AVA向晚</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672353429/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672353429&#x2F;" rel="noopener" target="_blank">Bella贝拉</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/351609538/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;351609538&#x2F;" rel="noopener" target="_blank">Carol珈乐</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672328094/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672328094&#x2F;" rel="noopener" target="_blank">Diana嘉然</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://space.bilibili.com/672342685/" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;672342685&#x2F;" rel="noopener" target="_blank">Eileen乃琳</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhenruyi.github.io/linux/webServer2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.jpg">
      <meta itemprop="name" content="luyizheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhenruyi">
      <meta itemprop="description" content="">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux多进程开发 | zhenruyi">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux多进程开发
        </h1>

        <div class="post-meta-container">

        

          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-18 18:08:42" itemprop="dateCreated datePublished" datetime="2022-04-18T18:08:42+08:00">2022-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-21 15:14:11" itemprop="dateModified" datetime="2022-04-21T15:14:11+08:00">2022-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>内容有：程序和进程概述、并行和并发、pcb进程信息管理、进程状态转换、进程相关命令、fork函数、父子进程用户区数据读写、多进程gdb调试、exec族函数、结束进程、孤儿进程、僵尸进程、wait、waitpid函数、进程间通信简介、匿名管道、有名管道、内存映射、信号、进程组和会话、守护进程。</p>
<span id="more"></span>



<hr>
<h3 id="1-进程概述"><a href="#1-进程概述" class="headerlink" title="1 进程概述"></a>1 进程概述</h3><h4 id="1-1-程序和进程"><a href="#1-1-程序和进程" class="headerlink" title="1.1 程序和进程"></a>1.1 程序和进程</h4><p>程序是包含一系列信息的文件：</p>
<ul>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息，内核利用这些信息来解释文件中的其他信息。（ELF：可执行可连接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行的起始指令位置。</li>
<li>数据：变量初始值和程序使用的字面量值（例如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</li>
<li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li>
</ul>
<p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p>
<h4 id="1-2-单道、多道程序设计"><a href="#1-2-单道、多道程序设计" class="headerlink" title="1.2 单道、多道程序设计"></a>1.2 单道、多道程序设计</h4><p>单道程序，即在计算机内存中只允许一个的程序运行。</p>
<p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</p>
<p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p>
<h4 id="1-3-时间片"><a href="#1-3-时间片" class="headerlink" title="1.3 时间片"></a>1.3 时间片</h4><p>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</p>
<p>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。</p>
<h4 id="1-4-并行和并发"><a href="#1-4-并行和并发" class="headerlink" title="1.4 并行和并发"></a>1.4 并行和并发</h4><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<h4 id="1-5-进程控制块（PCB）"><a href="#1-5-进程控制块（PCB）" class="headerlink" title="1.5 进程控制块（PCB）"></a>1.5 进程控制块（PCB）</h4><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux内核的进程控制块是 task_struct 结构体。在/usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：</p>
<ul>
<li>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数。</li>
<li>进程的状态：有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器。</li>
<li>描述虚拟地址空间的信息。</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录（Current Working Directory）。</li>
<li>umask 掩码。</li>
<li>文件描述符表，包含很多指向 file 结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户 id 和组 id。</li>
<li>会话（Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<hr>
<h3 id="2-进程状态转换"><a href="#2-进程状态转换" class="headerlink" title="2 进程状态转换"></a>2 进程状态转换</h3><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。 在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。</p>
<h4 id="2-1-进程状态的三态模型"><a href="#2-1-进程状态的三态模型" class="headerlink" title="2.1 进程状态的三态模型"></a>2.1 进程状态的三态模型</h4><p>运行态：进程占有处理器正在运行。</p>
<p>就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
<p>阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-1.png"></p>
<h4 id="2-2-进程状态的五态模型"><a href="#2-2-进程状态的五态模型" class="headerlink" title="2.2 进程状态的五态模型"></a>2.2 进程状态的五态模型</h4><p>新建态：进程刚被创建时的状态，尚未进入就绪队列。</p>
<p>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-2.png"></p>
<h4 id="2-3-进程相关命令"><a href="#2-3-进程相关命令" class="headerlink" title="2.3 进程相关命令"></a>2.3 进程相关命令</h4><h5 id="2-3-1-查看进程快照（静态）"><a href="#2-3-1-查看进程快照（静态）" class="headerlink" title="2.3.1 查看进程快照（静态）"></a>2.3.1 查看进程快照（静态）</h5><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">ps aux</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">ps ajx</span></span><br><span class="line"></span><br><span class="line">参数的意义：</span><br><span class="line">a：显示终端上的所有进程</span><br><span class="line">u：详细信息</span><br><span class="line">x：显示没有控制终端的进程</span><br><span class="line">j：列出与作业控制相关的信息</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps aux得到如下头部</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> <span class="title">PID</span> %CPU %MEM VSZ RSS TTY STAT <span class="literal">START</span> TIME COMMAND</span><br><span class="line"></span><br><span class="line">TTY：表示当前终端，命令行输入&gt; tty可查看当前终端。</span><br><span class="line"><span class="literal">START</span>：开始运行的时间</span><br><span class="line">TIME：运行时间</span><br><span class="line">STAT：状态，意义如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-3.png"></p>
<h5 id="2-3-2-实时显示进程"><a href="#2-3-2-实时显示进程" class="headerlink" title="2.3.2 实时显示进程"></a>2.3.2 实时显示进程</h5><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">top 			#默认3s刷新一次</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">top -d <span class="number">5</span>   	#指定5s刷新一次</span></span><br></pre></td></tr></table></figure>

<p>按以下键显示对结果的排序：</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-4.png"></p>
<h5 id="2-3-3-杀死进程"><a href="#2-3-3-杀死进程" class="headerlink" title="2.3.3 杀死进程"></a>2.3.3 杀死进程</h5><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">杀死进程</span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">kill [-signal] pid</span></span><br><span class="line"></span><br><span class="line">列出所有信号signal</span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">kill -l</span></span><br><span class="line"></span><br><span class="line">强制杀死进程，9是宏SIGKILL的编号</span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">kill -<span class="variable constant_">SIGKILL</span> pid</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">kill -<span class="number">9</span> pid</span></span><br><span class="line"></span><br><span class="line">通过进程名杀死进程</span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">killall name</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-进程号和相关函数"><a href="#2-4-进程号和相关函数" class="headerlink" title="2.4 进程号和相关函数"></a>2.4 进程号和相关函数</h4><p>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。 进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p>任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程， 对应的进程号称为父进程号（PPID）。</p>
<p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各 种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当 前的进程组号。</p>
<p>进程号和进程组相关函数：</p>
<ul>
<li>pid_t getpid(void); </li>
<li>pid_t getppid(void); </li>
<li>pid_t getpgid(pid_t pid);</li>
</ul>
<hr>
<h3 id="3-进程创建"><a href="#3-进程创建" class="headerlink" title="3 进程创建"></a>3 进程创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<h4 id="3-1-进程创建"><a href="#3-1-进程创建" class="headerlink" title="3.1 进程创建"></a>3.1 进程创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">函数的作用：用于创建子进程。</span><br><span class="line">返回值：</span><br><span class="line">	fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="line">	在父进程中返回创建的子进程的ID,在子进程中返回<span class="number">0</span></span><br><span class="line">	如何区分父进程和子进程：通过fork的返回值。</span><br><span class="line">	在父进程中返回<span class="number">-1</span>，表示创建子进程失败，并且设置errno</span><br><span class="line">    </span><br><span class="line">失败的两个主要原因：</span><br><span class="line"><span class="number">1.</span> 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</span><br><span class="line"><span class="number">2.</span> 系统内存不足，这时 errno 的值被设置为 ENOMEM</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从fork()函数开始，进程分出了一个子进程，两个进程同时运行代码。for循环可以看到，是交替运行的。</p>
<h4 id="3-2-父子进程虚拟地址"><a href="#3-2-父子进程虚拟地址" class="headerlink" title="3.2 父子进程虚拟地址"></a>3.2 父子进程虚拟地址</h4><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">父子进程之间的关系：</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">区别：</span></span><br><span class="line"><span class="attribute">1.fork()函数的返回值不同</span></span><br><span class="line"><span class="attribute">父进程中</span><span class="punctuation">:</span> <span class="string">&gt;0 返回的子进程的ID</span></span><br><span class="line"><span class="attribute">子进程中</span><span class="punctuation">:</span> <span class="string">=0</span></span><br><span class="line"></span><br><span class="line">2.pcb中的一些数据</span><br><span class="line">当前的进程的id pid</span><br><span class="line">当前的进程的父进程的id ppid</span><br><span class="line">信号集</span><br><span class="line"></span><br><span class="line">共同点：</span><br><span class="line">某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line"><span class="bullet">-</span> <span class="string">用户区的数据</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">文件描述符表</span></span><br><span class="line">        </span><br><span class="line">父子进程对变量是不是共享的？</span><br><span class="line"><span class="bullet">-</span> <span class="string">刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-5.png"></p>
<p>虚拟地址空间是物理地址的一个映射。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实际上，更准确来说，Linux 的 <span class="keyword">fork</span>() 使用是通过写时拷贝 (copy- on-<span class="keyword">write</span>) 实现。</span><br><span class="line">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span><br><span class="line">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span><br><span class="line">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span><br><span class="line">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span><br><span class="line">注意：<span class="keyword">fork</span>之后父子进程共享文件，</span><br><span class="line"><span class="keyword">fork</span>产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-3-GDB多进程调试"><a href="#3-3-GDB多进程调试" class="headerlink" title="3.3 GDB多进程调试"></a>3.3 GDB多进程调试</h4><p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-6.png"></p>
<hr>
<h3 id="4-exec函数族"><a href="#4-exec函数族" class="headerlink" title="4 exec函数族"></a>4 exec函数族</h3><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的 内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样， 颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵 魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。即，内核区的数据不变，用户区的数据会被替换。</p>
<p>因为使用exec()函数之后，原先进程的用户区数据都被替换了，所以一般不直接使用这个函数，而是fork()一个子进程，在子进程中使用exec()。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-7.png"></p>
<p>前六个函数都是标准C库的函数，最后一个是Linux系统函数，前六个都是最后一个的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execl(const char *path, const char *arg, ...);</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - path:需要指定的执行的文件的路径或者名称</span></span><br><span class="line"><span class="comment">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">				./a.out hello world</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// execl(&quot;hello&quot;,&quot;hello&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// 使用which ps可以得到这个ps命令的路径</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果execl成功了，只有父进程运行，因为子进程代码被替换了。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execlp(const char *file, const char *arg, ... );</span></span><br><span class="line"><span class="comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - file:需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">                a.out</span></span><br><span class="line"><span class="comment">                ps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execv(const char *path, char *const argv[]);</span></span><br><span class="line"><span class="comment">        argv是需要的参数的一个字符串数组</span></span><br><span class="line"><span class="comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">        execv(&quot;/bin/ps&quot;, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execve(const char *filename, char *const argv[], char *const envp[]);</span></span><br><span class="line"><span class="comment">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-进程控制"><a href="#5-进程控制" class="headerlink" title="5 进程控制"></a>5 进程控制</h3><h4 id="5-1-进程退出"><a href="#5-1-进程退出" class="headerlink" title="5.1 进程退出"></a>5.1 进程退出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="comment">// exit(0);</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用eixt()的时候，控制台会输出全部信息，</span></span><br><span class="line"><span class="comment">	使用_exit()的时候，控制台只会显示hello，因为world还在缓冲区里。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-8.png"></p>
<h4 id="5-2-孤儿进程"><a href="#5-2-孤儿进程" class="headerlink" title="5.2 孤儿进程"></a>5.2 孤儿进程</h4><p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程 （Orphan Process）。</p>
<p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init  进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</p>
<p>因此孤儿进程并不会有什么危害。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前是子进程，ppid是1，即init</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-3-僵尸进程"><a href="#5-3-僵尸进程" class="headerlink" title="5.3 僵尸进程"></a>5.3 僵尸进程</h4><p>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法 自己释放掉，需要父进程去释放。进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸 （Zombie）进程。</p>
<p>僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()  或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用， 但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进 程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入ps aux，看到子进程的stat是Z，表示是僵尸进程。</p>
<h4 id="5-4-进程回收"><a href="#5-4-进程回收" class="headerlink" title="5.4 进程回收"></a>5.4 进程回收</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内 存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息 （包括进程号、退出状态、运行时间等）。父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<p>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞， waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-9.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">        参数：int *wstatus</span></span><br><span class="line"><span class="comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            - 成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// int ret = wait(NULL);</span></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="type">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用循环创建多个子进程时，需要判断该进程是否为父进程，否则子进程也会进入循环，创建子进程的子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pid:</span></span><br><span class="line"><span class="comment">                pid &gt; 0 : 某个子进程的pid</span></span><br><span class="line"><span class="comment">                pid = 0 : 回收当前进程组的所有子进程    </span></span><br><span class="line"><span class="comment">                pid = -1 : 回收所有的子进程，相当于 wait()  （最常用）</span></span><br><span class="line"><span class="comment">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">            - options：设置阻塞或者非阻塞</span></span><br><span class="line"><span class="comment">                0 : 阻塞</span></span><br><span class="line"><span class="comment">                WNOHANG : 非阻塞</span></span><br><span class="line"><span class="comment">            - 返回值：</span></span><br><span class="line"><span class="comment">                &gt; 0 : 返回子进程的id</span></span><br><span class="line"><span class="comment">                = 0 : options=WNOHANG, 表示还有子进程或者</span></span><br><span class="line"><span class="comment">                = -1 ：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="comment">// int ret = waitpid(-1, &amp;st, 0);</span></span><br><span class="line">            <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, &amp;st, WNOHANG);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明还有子进程存在</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是正常退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是异常终止</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-进程间通信"><a href="#6-进程间通信" class="headerlink" title="6 进程间通信"></a>6 进程间通信</h3><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。进程间通信的目的：</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-10.png"></p>
<h4 id="6-1-匿名管道"><a href="#6-1-匿名管道" class="headerlink" title="6.1 匿名管道"></a>6.1 匿名管道</h4><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式， 所有的 UNIX 系统都支持这种通信机制。</p>
<p>统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两 个进程来分别执行 ls 和 wc。（ |：管道符，连接两个进程）。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-11.png"></p>
<p>进程默认打开的三个文件：标准输入fd=0，标准输出fd=1，标准错误fd=2。</p>
<h5 id="6-1-1-管道的特点"><a href="#6-1-1-管道的特点" class="headerlink" title="6.1.1 管道的特点"></a>6.1.1 管道的特点</h5><p>管道的特点：</p>
<ul>
<li><p>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。Linux下管道大小默认4k。</p>
</li>
<li><p>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</p>
</li>
<li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p>
</li>
<li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p>
</li>
<li><p>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</p>
</li>
<li><p>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。</p>
</li>
<li><p>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-12.png"></p>
</li>
</ul>
<h5 id="6-1-2-为什么可以使用管道进行进程间通信？"><a href="#6-1-2-为什么可以使用管道进行进程间通信？" class="headerlink" title="6.1.2 为什么可以使用管道进行进程间通信？"></a>6.1.2 为什么可以使用管道进行进程间通信？</h5><p>管道只能在具有公共祖先的进程之间使用，所以管道的创建要在fork函数之前。使用fork函数之后，父子进程的文件符表是一样的，都指向同一个管道文件，所以可以通信。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-13.png"></p>
<h5 id="6-1-3-管道的数据结构"><a href="#6-1-3-管道的数据结构" class="headerlink" title="6.1.3 管道的数据结构"></a>6.1.3 管道的数据结构</h5><p>管道的数据结构其实是一个循环数组，有读指针和写指针。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-14.png"></p>
<h5 id="6-1-4-父子进程通过管道进行通信"><a href="#6-1-4-父子进程通过管道进行通信" class="headerlink" title="6.1.4 父子进程通过管道进行通信"></a>6.1.4 父子进程通过管道进行通信</h5><p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-15.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment">        功能：创建一个匿名管道，用来进程间通信。</span></span><br><span class="line"><span class="comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment">            pipefd[0] 对应的是管道的读端</span></span><br><span class="line"><span class="comment">            pipefd[1] 对应的是管道的写端</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功 0</span></span><br><span class="line"><span class="comment">            失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="comment">//char * str = &quot;hello,i am parent&quot;;</span></span><br><span class="line">            <span class="comment">//write(pipefd[1], str, strlen(str));</span></span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">            <span class="comment">// int len = read(pipefd[0], buf, sizeof(buf));</span></span><br><span class="line">            <span class="comment">// printf(&quot;child recv : %s, pid : %d\n&quot;, buf, getpid());</span></span><br><span class="line">            <span class="comment">// bzero(buf, 1024);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ulimit -a产看管道缓冲区大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="comment">// 获取管道的大小</span></span><br><span class="line">    <span class="type">long</span> size = fpathconf(pipefd[<span class="number">0</span>], _PC_PIPE_BUF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipe size : %ld\n&quot;</span>, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-5-匿名管道的通信案例"><a href="#6-1-5-匿名管道的通信案例" class="headerlink" title="6.1.5 匿名管道的通信案例"></a>6.1.5 匿名管道的通信案例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现 ps aux | grep xxx 父子进程间通信</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    子进程： ps aux, 子进程结束后，将数据发送给父进程</span></span><br><span class="line"><span class="comment">    父进程：获取到数据，过滤</span></span><br><span class="line"><span class="comment">    pipe()</span></span><br><span class="line"><span class="comment">    execlp()</span></span><br><span class="line"><span class="comment">    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 过滤数据输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="comment">// 设置buf为0对应的字符，被设置的大小为1024</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        <span class="comment">// stdout_fileno其实等于1，等同于 dup2(fd[1], 1)</span></span><br><span class="line">        <span class="comment">// 原本的标准输出会将数据输出到显示器上，重定向之后会输出到fd[1]中</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-6-管道读写特点"><a href="#6-1-6-管道读写特点" class="headerlink" title="6.1.6 管道读写特点"></a>6.1.6 管道读写特点</h5><p>管道的读写特点：<br>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p>
<p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p>
<p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p>
<p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。</p>
<p>总结：</p>
<ul>
<li>读管道：<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>写端被全部关闭，read返回0（相当于读到文件的末尾）</li>
<li>写端没有完全关闭，read阻塞等待</li>
</ul>
</li>
</ul>
</li>
<li>写管道：<ul>
<li>管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞</li>
<li>管道没有满，write将数据写入，并返回实际写入的字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-1-7-管道设置为非阻塞"><a href="#6-1-7-管道设置为非阻塞" class="headerlink" title="6.1.7 管道设置为非阻塞"></a>6.1.7 管道设置为非阻塞</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-2-有名管道"><a href="#6-2-有名管道" class="headerlink" title="6.2 有名管道"></a>6.2 有名管道</h4><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO  的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p>
<p>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的 I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一 个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的 名称也由此而来：先入先出。</p>
<p>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： 1. FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 2. 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</p>
<h5 id="6-2-1-创建有名管道"><a href="#6-2-1-创建有名管道" class="headerlink" title="6.2.1 创建有名管道"></a>6.2.1 创建有名管道</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过命令创建有名管道</span><br><span class="line">mkfifo 名字</span><br><span class="line">mkfifo fifo1</span><br><span class="line"></span><br><span class="line">通过函数创建有名管道</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。</span><br><span class="line">FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</span><br></pre></td></tr></table></figure>

<h5 id="6-2-2-有名管道的使用"><a href="#6-2-2-有名管道的使用" class="headerlink" title="6.2.2 有名管道的使用"></a>6.2.2 有名管道的使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 管道名称的路径</span></span><br><span class="line"><span class="comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span></span><br><span class="line"><span class="comment">                    是一个八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1，并设置错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);        </span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    有名管道的注意事项：</span></span><br><span class="line"><span class="comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span></span><br><span class="line"><span class="comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读管道：</span></span><br><span class="line"><span class="comment">        管道中有数据，read返回实际读到的字节数</span></span><br><span class="line"><span class="comment">        管道中无数据：</span></span><br><span class="line"><span class="comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span></span><br><span class="line"><span class="comment">            写端没有全部被关闭，read阻塞等待</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    写管道：</span></span><br><span class="line"><span class="comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span></span><br><span class="line"><span class="comment">        管道读端没有全部关闭：</span></span><br><span class="line"><span class="comment">            管道已经满了，write会阻塞</span></span><br><span class="line"><span class="comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建管道文件</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-3-实现简单版聊天功能"><a href="#6-2-3-实现简单版聊天功能" class="headerlink" title="6.2.3 实现简单版聊天功能"></a>6.2.3 实现简单版聊天功能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chatA.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.以只写的方式打开管道fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.以只读的方式打开管道fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 4.循环的写读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 获取标准输入的数据</span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chatB.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.以只读的方式打开管道fifo1</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道fifo2</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 4.循环的读写数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 获取标准输入的数据</span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="7-内存映射"><a href="#7-内存映射" class="headerlink" title="7 内存映射"></a>7 内存映射</h3><p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-15.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-函数"><a href="#7-1-函数" class="headerlink" title="7.1 函数"></a>7.1 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span></span><br><span class="line"><span class="comment">        - 功能：将一个文件或者设备的数据映射到内存中</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - void *addr: NULL, 由内核指定</span></span><br><span class="line"><span class="comment">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span></span><br><span class="line"><span class="comment">                    获取文件的长度：stat lseek</span></span><br><span class="line"><span class="comment">            - prot : 对申请的内存映射区的操作权限</span></span><br><span class="line"><span class="comment">                -PROT_EXEC ：可执行的权限</span></span><br><span class="line"><span class="comment">                -PROT_READ ：读权限</span></span><br><span class="line"><span class="comment">                -PROT_WRITE ：写权限</span></span><br><span class="line"><span class="comment">                -PROT_NONE ：没有权限</span></span><br><span class="line"><span class="comment">                要操作映射内存，必须要有读的权限。</span></span><br><span class="line"><span class="comment">                PROT_READ、PROT_READ|PROT_WRITE</span></span><br><span class="line"><span class="comment">            - flags :</span></span><br><span class="line"><span class="comment">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span></span><br><span class="line"><span class="comment">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span></span><br><span class="line"><span class="comment">            - fd: 需要映射的那个文件的文件描述符</span></span><br><span class="line"><span class="comment">                - 通过open得到，open的是一个磁盘文件</span></span><br><span class="line"><span class="comment">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span></span><br><span class="line"><span class="comment">                    prot: PROT_READ                open:只读/读写 </span></span><br><span class="line"><span class="comment">                    prot: PROT_READ | PROT_WRITE   open:读写</span></span><br><span class="line"><span class="comment">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。</span></span><br><span class="line"><span class="comment">        - 返回值：返回创建的内存的首地址</span></span><br><span class="line"><span class="comment">            失败返回MAP_FAILED，(void *) -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int munmap(void *addr, size_t length);</span></span><br><span class="line"><span class="comment">        - 功能：释放内存映射</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - addr : 要释放的内存的首地址</span></span><br><span class="line"><span class="comment">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用内存映射实现进程间通信：</span></span><br><span class="line"><span class="comment">    1.有关系的进程（父子进程）</span></span><br><span class="line"><span class="comment">        - 还没有子进程的时候</span></span><br><span class="line"><span class="comment">            - 通过唯一的父进程，先创建内存映射区</span></span><br><span class="line"><span class="comment">        - 有了内存映射区以后，创建子进程</span></span><br><span class="line"><span class="comment">        - 父子进程共享创建的内存映射区</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2.没有关系的进程间通信</span></span><br><span class="line"><span class="comment">        - 准备一个大小不是0的磁盘文件</span></span><br><span class="line"><span class="comment">        - 进程1 通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">            - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">        - 进程2 通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">            - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">        - 使用内存映射区通信</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：内存映射区通信，是非阻塞。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作业:使用内存映射实现没有关系的进程间的通信。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">// 获取文件的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">       </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;nihao a, son!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-注意事项"><a href="#7-2-注意事项" class="headerlink" title="7.2 注意事项"></a>7.2 注意事项</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</span><br><span class="line">void * ptr = mmap(...);</span><br><span class="line">ptr++;  可以对其进行++操作</span><br><span class="line">munmap(ptr, len);   <span class="regexp">//</span> 错误,要保存地址</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.如果<span class="keyword">open</span>时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</span><br><span class="line">错误，返回MAP_FAILED</span><br><span class="line"><span class="keyword">open</span>()函数中的权限建议和prot参数的权限保持一致。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.如果文件偏移量为<span class="number">1000</span>会怎样?</span><br><span class="line">偏移量必须是<span class="number">4</span>K的整数倍，返回MAP_FAILED</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.mmap什么情况下会调用失败?</span><br><span class="line">    - 第二个参数：<span class="keyword">length</span> = <span class="number">0</span></span><br><span class="line">    - 第三个参数：prot</span><br><span class="line">        - 只指定了写权限</span><br><span class="line">        - prot PROT_READ | PROT_WRITE</span><br><span class="line">          第<span class="number">5</span>个参数fd 通过<span class="keyword">open</span>函数时指定的 O_RDONLY / O_WRONLY</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.可以<span class="keyword">open</span>的时候O_CREAT一个新文件来创建映射区吗?</span><br><span class="line">    - 可以的，但是创建的文件的大小如果为<span class="number">0</span>的话，肯定不行</span><br><span class="line">    - 可以对新的文件进行扩展</span><br><span class="line">        - lseek()</span><br><span class="line">        - <span class="keyword">truncate</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.mmap后关闭文件描述符，对mmap映射有没有影响？</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="keyword">open</span>(<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line">    mmap(,,,,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">close</span>(fd); </span><br><span class="line">    映射区还存在，创建映射区的fd被关闭，没有任何影响。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.对ptr越界操作会怎样？</span><br><span class="line">void * ptr = mmap(NULL, <span class="number">100</span>,,,,,);</span><br><span class="line"><span class="number">4</span>K，跟磁盘的分页有关</span><br><span class="line">越界操作操作的是非法的内存 -&gt; 段错误</span><br></pre></td></tr></table></figure>

<h4 id="7-3-实现复制文件操作"><a href="#7-3-实现复制文件操作" class="headerlink" title="7.3 实现复制文件操作"></a>7.3 实现复制文件操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用内存映射实现文件拷贝的功能</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1.对原始的文件进行内存映射</span></span><br><span class="line"><span class="comment">        2.创建一个新文件（拓展该文件）</span></span><br><span class="line"><span class="comment">        3.把新文件的数据映射到内存中</span></span><br><span class="line"><span class="comment">        4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中</span></span><br><span class="line"><span class="comment">        5.释放资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新文件（拓展该文件）</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> * ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-匿名映射"><a href="#7-4-匿名映射" class="headerlink" title="7.4 匿名映射"></a>7.4 匿名映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名映射：不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *) ptr, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="8-信号"><a href="#8-信号" class="headerlink" title="8 信号"></a>8 信号</h3><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也 称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号 可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C  通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给 相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的 内存区域。</li>
<li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU  时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
<p>使用信号的两个主要目的是：第一，让进程知道已经发生了一个特定的事情。第二，强迫进程执行它自己代码中的信号处理程序。</p>
<p>信号的特点：简单。不能携带大量信息。满足某个特定条件才发送。优先级比较高。</p>
<h4 id="8-1-信号列表"><a href="#8-1-信号列表" class="headerlink" title="8.1 信号列表"></a>8.1 信号列表</h4><p>查看系统定义的信号列表：<code>kill -l</code>。前 31 个信号为常规信号，其余为实时信号。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-16.png"></p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-17.png"></p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-18.png"></p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-19.png"></p>
<h4 id="8-2-信号的5种默认处理动作"><a href="#8-2-信号的5种默认处理动作" class="headerlink" title="8.2 信号的5种默认处理动作"></a>8.2 信号的5种默认处理动作</h4><p>查看信号的详细信息：<code>man 7 signal</code>。信号的几种状态：产生、未决、递达。SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。信号的 5 中默认处理动作：</p>
<ul>
<li>Term：终止进程。</li>
<li>Ign：当前进程忽略掉这个信号。</li>
<li>Core：终止进程，并产生一个Core文件。</li>
<li>Stop：暂停当前进程。</li>
<li>Cont：继续执行被暂停的进程。</li>
</ul>
<h4 id="8-3-Core文件的生成和调试"><a href="#8-3-Core文件的生成和调试" class="headerlink" title="8.3 Core文件的生成和调试"></a>8.3 Core文件的生成和调试</h4><p>编写一个错误的程序，执行过后，发现没有生成Core文件。使用<code>ulimit -a</code>查看当前进程的限制，发现<code>core file size</code>是0，使用<code>ulimit -c 1024</code>打开Core文件写的权限，再次运行错误的程序，就能得到一个Core文件了。</p>
<p>进入调试程序gdb，输入<code>core-file core</code>可以得到错误信息的具体位置。</p>
<h4 id="8-4-kill、raise、abort函数"><a href="#8-4-kill、raise、abort函数" class="headerlink" title="8.4 kill、raise、abort函数"></a>8.4 kill、raise、abort函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int kill(pid_t pid, int sig);</span></span><br><span class="line"><span class="comment">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - pid ：</span></span><br><span class="line"><span class="comment">                &gt; 0 : 将信号发送给指定的进程</span></span><br><span class="line"><span class="comment">                = 0 : 将信号发送给当前的进程组</span></span><br><span class="line"><span class="comment">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span></span><br><span class="line"><span class="comment">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span></span><br><span class="line"><span class="comment">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        kill(getppid(), 9);</span></span><br><span class="line"><span class="comment">        kill(getpid(), 9);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    int raise(int sig);</span></span><br><span class="line"><span class="comment">        - 功能：给当前进程发送信号</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - sig : 要发送的信号</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            - 成功 0</span></span><br><span class="line"><span class="comment">            - 失败 非0</span></span><br><span class="line"><span class="comment">        kill(getpid(), sig);   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void abort(void);</span></span><br><span class="line"><span class="comment">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span></span><br><span class="line"><span class="comment">        kill(getpid(), SIGABRT);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kill child process now\n&quot;</span>);</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-5-alarm函数"><a href="#8-5-alarm函数" class="headerlink" title="8.5 alarm函数"></a>8.5 alarm函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    unsigned int alarm(unsigned int seconds);</span></span><br><span class="line"><span class="comment">        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span></span><br><span class="line"><span class="comment">                函数会给当前的进程发送一个信号：SIGALARM</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span></span><br><span class="line"><span class="comment">                    取消一个定时器，通过alarm(0)。</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            - 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">            - 之前有定时器，返回之前的定时器剩余的时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span></span><br><span class="line"><span class="comment">        alarm(10);  -&gt; 返回0</span></span><br><span class="line"><span class="comment">        过了1秒</span></span><br><span class="line"><span class="comment">        alarm(5);   -&gt; 返回9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    alarm(100) -&gt; 该函数是不阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    seconds = alarm(<span class="number">2</span>);    <span class="comment">// 不阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1秒钟电脑能数多少个数？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实际的时间 = 内核时间 + 用户时间 + 消耗的时间</span></span><br><span class="line"><span class="comment">    进行文件IO操作的时候比较浪费时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-6-setitimer函数"><a href="#8-6-setitimer函数" class="headerlink" title="8.6 setitimer函数"></a>8.6 setitimer函数</h4><p>alarm函数只能定时一次，setitimer函数可以周期性定时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">    int setitimer(int which, const struct itimerval *new_value,</span></span><br><span class="line"><span class="comment">                        struct itimerval *old_value);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - which : 定时器以什么时间计时</span></span><br><span class="line"><span class="comment">              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span></span><br><span class="line"><span class="comment">              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span></span><br><span class="line"><span class="comment">              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - new_value: 设置定时器的属性</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">                struct itimerval &#123;      // 定时器的结构体</span></span><br><span class="line"><span class="comment">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span></span><br><span class="line"><span class="comment">                struct timeval it_value;     // 延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment">                &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                struct timeval &#123;        // 时间的结构体</span></span><br><span class="line"><span class="comment">                    time_t      tv_sec;     //  秒数     </span></span><br><span class="line"><span class="comment">                    suseconds_t tv_usec;    //  微秒    </span></span><br><span class="line"><span class="comment">                &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            过10秒后，每个2秒定时一次</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功 0</span></span><br><span class="line"><span class="comment">            失败 -1 并设置错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现只定时了一次程序就结束了，没有实现周期性定时的功能。因为没有捕捉信号，然后处理信号，所以进程受到一个信号函数就执行默认功能结束进程了。</p>
<h4 id="8-7-signal信号捕捉函数"><a href="#8-7-signal信号捕捉函数" class="headerlink" title="8.7 signal信号捕捉函数"></a>8.7 signal信号捕捉函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    typedef void (*sighandler_t)(int);</span></span><br><span class="line"><span class="comment">    sighandler_t signal(int signum, sighandler_t handler);</span></span><br><span class="line"><span class="comment">        - 功能：设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - signum: 要捕捉的信号</span></span><br><span class="line"><span class="comment">            - handler: 捕捉到信号要如何处理</span></span><br><span class="line"><span class="comment">                - SIG_IGN ： 忽略信号</span></span><br><span class="line"><span class="comment">                - SIG_DFL ： 使用信号默认的行为</span></span><br><span class="line"><span class="comment">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span></span><br><span class="line"><span class="comment">                回调函数：</span></span><br><span class="line"><span class="comment">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span></span><br><span class="line"><span class="comment">                    - 不是程序员调用，而是当信号产生，由内核调用</span></span><br><span class="line"><span class="comment">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span></span><br><span class="line"><span class="comment">            失败，返回SIG_ERR，设置错误号</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_DFL);</span></span><br><span class="line">    <span class="comment">// void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span></span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-信号集"><a href="#8-8-信号集" class="headerlink" title="8.8 信号集"></a>8.8 信号集</h4><p>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为 信号集的数据结构来表示，其系统数据类型为 sigset_t。</p>
<p>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为 “未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我 们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数 来对 PCB 中的这两个信号集进行修改。</p>
<p>位图就是使用64位来表示一个集合，每一位都表示特定的功能，使用位运算可以实现修改、判断等功能。</p>
<p>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</p>
<p>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</p>
<p>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号， 所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</p>
<p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-20.png"></p>
<h4 id="8-9-阻塞信号集和未决信号集"><a href="#8-9-阻塞信号集和未决信号集" class="headerlink" title="8.9 阻塞信号集和未决信号集"></a>8.9 阻塞信号集和未决信号集</h4><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</span><br><span class="line"></span><br><span class="line">2.信号产生但是没有被处理 （未决）</span><br><span class="line">    <span class="bullet">-</span> <span class="string">在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SIGINT信号状态被存储在第二个标志位上</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">这个标志位的值为0， 说明信号不是未决状态</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">这个标志位的值为1， 说明信号处于未决状态</span></span><br><span class="line">    </span><br><span class="line">3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</span><br><span class="line">    <span class="bullet">-</span> <span class="string">阻塞信号集默认不阻塞任何的信号</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">如果想要阻塞某些信号需要用户调用系统的API</span></span><br><span class="line"></span><br><span class="line">4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</span><br><span class="line">    <span class="bullet">-</span> <span class="string">如果没有阻塞，这个信号就被处理</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</span></span><br></pre></td></tr></table></figure>



<h4 id="8-10-用户自定义信号集"><a href="#8-10-用户自定义信号集" class="headerlink" title="8.10 用户自定义信号集"></a>8.10 用户自定义信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    以下信号集相关的函数都是对自定义的信号集进行操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigemptyset(sigset_t *set);</span></span><br><span class="line"><span class="comment">        - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span></span><br><span class="line"><span class="comment">        - 参数：set,传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigfillset(sigset_t *set);</span></span><br><span class="line"><span class="comment">        - 功能：将信号集中的所有的标志位置为1</span></span><br><span class="line"><span class="comment">        - 参数：set,传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigaddset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - set：传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">            - signum：需要设置阻塞的那个信号</span></span><br><span class="line"><span class="comment">        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigdelset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - set：传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">            - signum：需要设置不阻塞的那个信号</span></span><br><span class="line"><span class="comment">        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigismember(const sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">        - 功能：判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - set：需要操作的信号集</span></span><br><span class="line"><span class="comment">            - signum：需要判断的那个信号</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            1 ： signum被阻塞</span></span><br><span class="line"><span class="comment">            0 ： signum不阻塞</span></span><br><span class="line"><span class="comment">            -1 ： 失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空信号集的内容</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="type">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-11-用自定义信号集修改系统信号集"><a href="#8-11-用自定义信号集修改系统信号集" class="headerlink" title="8.11 用自定义信号集修改系统信号集"></a>8.11 用自定义信号集修改系统信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span></span><br><span class="line"><span class="comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - how : 如何对内核阻塞信号集进行处理</span></span><br><span class="line"><span class="comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span></span><br><span class="line"><span class="comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span></span><br><span class="line"><span class="comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span></span><br><span class="line"><span class="comment">                    mask &amp;= ~set，即为1的位清除</span></span><br><span class="line"><span class="comment">                SIG_SETMASK:覆盖内核中原来的值</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            - set ：已经初始化好的用户自定义的信号集</span></span><br><span class="line"><span class="comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功：0</span></span><br><span class="line"><span class="comment">            失败：-1</span></span><br><span class="line"><span class="comment">                设置错误号：EFAULT、EINVAL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigpending(sigset_t *set);</span></span><br><span class="line"><span class="comment">        - 功能：获取内核中的未决信号集</span></span><br><span class="line"><span class="comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span></span><br><span class="line"><span class="comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置2、3号信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 将2号和3号信号添加到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改内核中的阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">// 获取当前的未决信号集的数据</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历前32位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">31</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;sigismember&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞时，按下Ctrl+c不能结束进程。</p>
<p>在运行可执行文件时后面输入&amp;号，可以让程序在后台运行。<code>./app &amp;</code>。</p>
<p>程序占用前台，不能输入其他命令，程序在后台的时候可以输入其他命令。程序在后台依旧可以输出内容。</p>
<h4 id="8-12-sigaction信号捕捉函数"><a href="#8-12-sigaction信号捕捉函数" class="headerlink" title="8.12 sigaction信号捕捉函数"></a>8.12 sigaction信号捕捉函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    int sigaction(int signum, const struct sigaction *act,</span></span><br><span class="line"><span class="comment">                            struct sigaction *oldact);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 功能：检查或者改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span></span><br><span class="line"><span class="comment">            - act ：捕捉到信号之后的处理动作</span></span><br><span class="line"><span class="comment">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功 0</span></span><br><span class="line"><span class="comment">            失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     struct sigaction &#123;</span></span><br><span class="line"><span class="comment">        // 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line"><span class="comment">        void     (*sa_handler)(int);</span></span><br><span class="line"><span class="comment">        // 不常用</span></span><br><span class="line"><span class="comment">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span></span><br><span class="line"><span class="comment">        // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line"><span class="comment">        sigset_t   sa_mask;</span></span><br><span class="line"><span class="comment">        // 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line"><span class="comment">        // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line"><span class="comment">        int        sa_flags;</span></span><br><span class="line"><span class="comment">        // 被废弃掉了</span></span><br><span class="line"><span class="comment">        void     (*sa_restorer)(void);</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);  <span class="comment">// 清空临时阻塞信号集</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-13-内核实现信号捕捉的过程"><a href="#8-13-内核实现信号捕捉的过程" class="headerlink" title="8.13 内核实现信号捕捉的过程"></a>8.13 内核实现信号捕捉的过程</h4><p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-21.png"></p>
<h4 id="8-14-SIGCHLD信号"><a href="#8-14-SIGCHLD信号" class="headerlink" title="8.14 SIGCHLD信号"></a>8.14 SIGCHLD信号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    SIGCHLD信号产生的3个条件：</span></span><br><span class="line"><span class="comment">        1.子进程结束</span></span><br><span class="line"><span class="comment">        2.子进程暂停了</span></span><br><span class="line"><span class="comment">        3.子进程继续运行</span></span><br><span class="line"><span class="comment">        都会给父进程发送该信号，父进程默认忽略该信号。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    使用SIGCHLD信号解决僵尸进程的问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号 ：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 回收子进程PCB的资源</span></span><br><span class="line">    <span class="comment">// while(1) &#123;</span></span><br><span class="line">    <span class="comment">//     wait(NULL); </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">       <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d\n&quot;</span>, ret);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 说明还有子进程或者</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">           <span class="comment">// 没有子进程</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册完信号捕捉以后，解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid : %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="9-共享内存"><a href="#9-共享内存" class="headerlink" title="9 共享内存"></a>9 共享内存</h3><p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于 一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介 入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其 他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据 从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</p>
<h4 id="9-1-使用步骤"><a href="#9-1-使用步骤" class="headerlink" title="9.1 使用步骤"></a>9.1 使用步骤</h4><ol>
<li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其 他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。</li>
<li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之 后内存段才会销毁。只有一个进程需要执行这一步。</li>
</ol>
<h4 id="9-2-相关函数"><a href="#9-2-相关函数" class="headerlink" title="9.2 相关函数"></a>9.2 相关函数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="function"><span class="literal">NULL</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体<span class="keyword">struct</span> <span class="title class_">shmid_ds</span> 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br><span class="line"></span><br><span class="line">问题<span class="number">2</span>：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为<span class="number">0</span>的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为<span class="number">0</span>的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br><span class="line"></span><br><span class="line">    共享内存和内存映射的区别</span><br><span class="line">    <span class="number">1.</span>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="line">    <span class="number">2.</span>共享内存效果更高</span><br><span class="line">    <span class="number">3.</span>内存</span><br><span class="line">        所有的进程操作的是同一块共享内存。</span><br><span class="line">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="line">    <span class="number">4.</span>数据安全</span><br><span class="line">        - 进程突然退出</span><br><span class="line">            共享内存还存在</span><br><span class="line">            内存映射区消失</span><br><span class="line">        - 运行进程的电脑死机，宕机了</span><br><span class="line">            数据存在在共享内存中，没有了</span><br><span class="line">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="line"></span><br><span class="line">    <span class="number">5.</span>生命周期</span><br><span class="line">        - 内存映射区：进程退出，内存映射区销毁</span><br><span class="line">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为<span class="number">0</span>），或者关机</span><br><span class="line">            如果一个进程退出，会自动和共享内存进行取消关联。</span><br></pre></td></tr></table></figure>

<h4 id="9-3-实现案例"><a href="#9-3-实现案例" class="headerlink" title="9.3 实现案例"></a>9.3 实现案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read_shm.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_shm.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-4-共享内存操作命令"><a href="#9-4-共享内存操作命令" class="headerlink" title="9.4 共享内存操作命令"></a>9.4 共享内存操作命令</h4><p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-22.png"></p>
<h3 id="10-守护进程"><a href="#10-守护进程" class="headerlink" title="10 守护进程"></a>10 守护进程</h3><h4 id="10-1-终端"><a href="#10-1-终端" class="headerlink" title="10.1 终端"></a>10.1 终端</h4><p>在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成 为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是 保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进 程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指 向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准 错误输出写也就是输出到显示器上。</p>
<p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产 生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</p>
<h4 id="10-2-进程组"><a href="#10-2-进程组" class="headerlink" title="10.2 进程组"></a>10.2 进程组</h4><p>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合， 会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽 象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p>
<p>进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一 个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程 会继承其父进程所属的进程组 ID。</p>
<p>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个 成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入 了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p>
<h4 id="10-3-会话"><a href="#10-3-会话" class="headerlink" title="10.3 会话"></a>10.3 会话</h4><p>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会 话 ID。新进程会继承其父进程的会话 ID。</p>
<p>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终 端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</p>
<p>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为 后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终 端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p>
<p>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p>
<h4 id="10-4-进程、进程组、会话、控制终端之间的关系"><a href="#10-4-进程、进程组、会话、控制终端之间的关系" class="headerlink" title="10.4 进程、进程组、会话、控制终端之间的关系"></a>10.4 进程、进程组、会话、控制终端之间的关系</h4><p><img src="https://zhenruyi.github.io/images/webServer/LinuxProgStart3-23.png"></p>
<h4 id="10-5-进程组、会话的操作函数"><a href="#10-5-进程组、会话的操作函数" class="headerlink" title="10.5 进程组、会话的操作函数"></a>10.5 进程组、会话的操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">获取组id</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">获取指定进程的组id</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line">设置指定进程的组id</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">获取会话id</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">创建新的会话，id设置为当前进程的id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-6-守护进程"><a href="#10-6-守护进程" class="headerlink" title="10.6 守护进程"></a>10.6 守护进程</h4><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周 期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p>
<p>守护进程具备下列特征：生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进 程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd， Web 服务器 httpd 等。</p>
<h4 id="10-7-守护进程的创建步骤"><a href="#10-7-守护进程的创建步骤" class="headerlink" title="10.7 守护进程的创建步骤"></a>10.7 守护进程的创建步骤</h4><p>◼ 执行一个 fork()，之后父进程退出，子进程继续执行。 </p>
<p>◼ 子进程调用 setsid() 开启一个新会话。 </p>
<p>◼ 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</p>
<p>◼ 修改进程的当前工作目录，通常会改为根目录（/）。 </p>
<p>◼ 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 </p>
<p>◼ 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2()  使所有这些描述符指向这个设备。 </p>
<p>◼ 核心业务逻辑</p>
<h4 id="10-8-实例"><a href="#10-8-实例" class="headerlink" title="10.8 实例"></a>10.8 实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间，写入磁盘文件</span></span><br><span class="line">    <span class="type">time_t</span> tm = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d-%d-%d %d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon</span></span><br><span class="line">    <span class="comment">// ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd ,str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将子进程重新创建一个会话</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/nowcoder/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕捉定时信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不让进程结束</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/webServer/" rel="tag"># webServer</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/linux/webServer1/" rel="prev" title="Linux系统编程入门">
                  <i class="fa fa-chevron-left"></i> Linux系统编程入门
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/linux/webServer3/" rel="next" title="Linux多线程开发">
                  Linux多线程开发 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyizheng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  





</body>
</html>
